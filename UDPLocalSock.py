import socketimport randomimport subprocessimport threadingimport sysimport tracebackimport timeimport ChatWindow"""	Localsock is to send and receive chat messages, it interacts with other locals"""online_list = []chatwindow_list = []def chat():	local = create_localsock()		# start to receive message	recv_thread = threading.Thread(name='Listening', target=recv_message, args=(local[0],))	recv_thread.start()		while True:		# let everyone know I'm online!		im_online(local[0], local[1][1])		address = raw_input('Enter quit to end program. To chat with someone, enter your peer\'s address:')		if address == 'quit':			# should notify peers that I'm offline			for peer in online_list:				send_message(local[0], peer, 'I\'m offline!')			local[0].close()			break		try:			window_subproc = subprocess.Popen('ChatWindow.py ' + str(local) + ' ' + address,												shell=True,												stdin=subprocess.PIPE,												stdout=subprocess.PIPE												)			#			window_thread = threading.Thread(name=address, target=ChatWindow.create_window, args=(local[0], address))			chatwindow_list.append((address,window_subproc))						listen_window = threading.Thread(target=recvfrom_window, args=(local_sock, address, window_subproc))			listen_window.start()#			window_thread.start()		except:			print 'Failed to create chat window! Your address may be wrong. ' + address		# initiate chat(create a chat window)		# Can send message to remote_addr		# close local_socket to end program			print 'Bye!'def create_localsock():	local_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)	# UDP socket	local_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)	local_port = random.randint(9990,10000)	#	Use random port to test on localhost, it can be set to a fixed value in real network	print local_port	local_addr = ('localhost', local_port)		try:		local_sock.bind(local_addr)	except:		print 'Error occured while binding local sock, the port maybe occupied.'		sys.exit(1)		return local_sock, local_addr		def recv_message(local_sock):	print 'Start listening message.'	while True:		try:			try:				message, address = local_sock.recvfrom(4096)			except:				#print 'Exception in recv_message!'				continue			if address not in online_list:				online_list.append(address)				print str(online_list) + ' is online!'				send_message(local_sock, address, 'Copy!')			elif message == 'I\'m offline!':				online_list.remove(address)#			elif message == 'Copy!':#				pass			else:				window = [window for window in chatwindow_list if window[0] == address]				#print message, window, len(window)				if len(window) == 0:					#open_command = 'python D:\\\\"Python Excise\P2P_UDP_IM\ChatWindow.py\" ' + str(local_sock) + ' ' + str(address)					print 'Message from: ' + str(address)					open_command = 'ChatWindow.py ' + str(address)					print open_command					window_subproc = subprocess.Popen(open_command,												shell=True,												stdin=subprocess.PIPE,												stdout=subprocess.PIPE												)					chatwindow_list.append((address, window_subproc))										print 'Message received: ' + message										window_subproc.stdin.write('Your peer says:' + message)					print str(address) + ' ' + message					window_subproc.stdin.flush()										listen_window = threading.Thread(target=recvfrom_window, args=(local_sock, address, window_subproc))					listen_window.start()										time.sleep(1)										#print 'Message received after: ' + message					# print message to the window				elif len(window) == 1:					# print message to the corresponding window					print 'Message received: ' + message					window[0][1].stdin.write('Your peer says:' + message)					print str(address) + ' ' + message					window[0][1].stdin.flush()					#print 'Message received after: ' + message					pass				else:					print 'ERROR! More than one chat window to same address!'		except:			traceback.print_exc()			print 'Exception in recv_message.'			return			def send_message(local_sock, remote_sock, message):	sent = local_sock.sendto(message, remote_sock)# recv input in window then send it to remote sockdef recvfrom_window(local_sock, remote_sock, window_subproc):	print 'recvfrom window'	while True:		message = window_subproc.stdout.readline()		if not message:			time.sleep(1)		else:			send_message(local_sock, remote_sock, message)				def im_online(local_sock, my_port):	#print 'I\'m online!'	for i in range(9990, 10000):	# just for test		if i != my_port:			sent = local_sock.sendto('I\'m online!', ('localhost', i))	print 'I\'m online!'if __name__ == '__main__':	chat()